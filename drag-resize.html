<link rel="import" href="../polymer/polymer-element.html">
<link rel="import" href="../polymer/lib/mixins/gesture-event-listeners.html">
<link rel="import" href="../polymer/lib/utils/flattened-nodes-observer.html">
<link rel="import" href="../iron-flex-layout/iron-flex-layout.html">
<link rel="import" href="../shadycss/apply-shim.html">
<!--
  CSS custom property | Description | Default
  ------------------- | ----------- | -------
  `--drag-resize-handle-size` | draggable edge/corner size | 8px;
  `--drag-resize-corner-color` | color for resizable corner | '';
  `--drag-resize-edge-border` | border for resizable edges | '';
  `--drag-resize-corner-border` | border for resizable corners | '';
  `--drag-resize-container` | Mixin applied to resize container | {};
  `--drag-resize-move-cursor` | move cursor | move;
  `--drag-resize-top-cursor` | top cursor | ns-resize;
  `--drag-resize-bottom-cursor` | bottom cursor | ns-resize;
  `--drag-resize-left-cursor` | left cursor | ew-resize;
  `--drag-resize-right-cursor` | right cursor | ew-resize;
  `--drag-resize-top-left-cursor` | top-left cursor | nw-resize;
  `--drag-resize-top-right-cursor` | top-right cursor | ne-resize;
  `--drag-resize-bottom-left-cursor` | bottom-left cursor | sw-resize;
  `--drag-resize-bottom-right-cursor` | bottom-right cursor | se-resize;
-->
<dom-module id="drag-resize">
  <template strip-whitespace>
    <style>
      :host {
        display: inline-block;
        --drag-resize-handle-size: 8px;
        --drag-resize-move-cursor: move;
        --drag-resize-top-cursor: ns-resize;
        --drag-resize-bottom-cursor: ns-resize;
        --drag-resize-left-cursor: ew-resize;
        --drag-resize-right-cursor: ew-resize;
        --drag-resize-top-left-cursor: nw-resize;
        --drag-resize-top-right-cursor: ne-resize;
        --drag-resize-bottom-left-cursor: sw-resize;
        --drag-resize-bottom-right-cursor: se-resize;
      }

      :host([draggable]) #fit {
        cursor: var(--drag-resize-move-cursor, inherit);
      }
      #container {
        position: relative;
        box-sizing: border-box;
        @apply --drag-resize-container;

      }
      #fit {
        position: absolute;
        top: 0;
        left: 0;
        bottom: 0;
        right: 0;
      }
      #top {
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        border-top: var(--drag-resize-edge-border);
        height: var(--drag-resize-handle-size);
        cursor: var(--drag-resize-top-cursor);
      }
      #right {
        position: absolute;
        top: 0;
        right: 0;
        bottom: 0;
        border-right: var(--drag-resize-edge-border);
        width: var(--drag-resize-handle-size);
        cursor: var(--drag-resize-right-cursor);
      }
      #bottom {
        position: absolute;
        bottom: 0;
        left: 0;
        right: 0;
        border-bottom: var(--drag-resize-edge-border);
        height: var(--drag-resize-handle-size);
        cursor: var(--drag-resize-bottom-cursor);
      }
      #left {
        position: absolute;
        top: 0;
        left: 0;
        bottom: 0;
        border-left: var(--drag-resize-edge-border);
        width: var(--drag-resize-handle-size);
        cursor: var(--drag-resize-left-cursor);
      }

      #topLeft {
        position: absolute;
        top: calc(var(--drag-resize-handle-size) / -2);
        left: calc(var(--drag-resize-handle-size) / -2);
        width: calc(var(--drag-resize-handle-size) * 2);
        height: calc(var(--drag-resize-handle-size) * 2);
        cursor: var(--drag-resize-top-left-cursor);
        border-top: var(--drag-resize-corner-border);
        border-left: var(--drag-resize-corner-border);
        background-image: linear-gradient(to top left, rgba(0,0,0,0) 75%,
          var(--drag-resize-corner-color, rgba(0,0,0,0)));
        z-index: 1;
      }
      #topRight {
        position: absolute;
        top: calc(var(--drag-resize-handle-size) / -2);
        right: calc(var(--drag-resize-handle-size) / -2);
        width: calc(var(--drag-resize-handle-size) * 2);
        height: calc(var(--drag-resize-handle-size) * 2);
        cursor: var(--drag-resize-top-right-cursor);
        border-top: var(--drag-resize-corner-border);
        border-right: var(--drag-resize-corner-border);
        background-image: linear-gradient(to top right, rgba(0,0,0,0) 75%,
          var(--drag-resize-corner-color, rgba(0,0,0,0)));
        z-index: 1;
      }
      #bottomLeft {
        position: absolute;
        bottom: calc(var(--drag-resize-handle-size) / -2);
        left: calc(var(--drag-resize-handle-size) / -2);
        width: calc(var(--drag-resize-handle-size) * 2);
        height: calc(var(--drag-resize-handle-size) * 2);
        cursor: var(--drag-resize-bottom-left-cursor);
        border-bottom: var(--drag-resize-corner-border);
        border-left: var(--drag-resize-corner-border);
        background-image: linear-gradient(to bottom left, rgba(0,0,0,0) 75%,
          var(--drag-resize-corner-color, rgba(0,0,0,0)));
        z-index: 1;
      }
      #bottomRight {
        position: absolute;
        bottom: calc(var(--drag-resize-handle-size) / -2);
        right: calc(var(--drag-resize-handle-size) / -2);
        width: calc(var(--drag-resize-handle-size) * 2);
        height: calc(var(--drag-resize-handle-size) * 2);
        cursor: var(--drag-resize-bottom-right-cursor);
        border-bottom: var(--drag-resize-corner-border);
        border-right: var(--drag-resize-corner-border);
        background-image: linear-gradient(to bottom right, rgba(0,0,0,0) 75%,
          var(--drag-resize-corner-color, rgba(0,0,0,0)));
        z-index: 1;
      }
    </style>
    <div id="container">
      <slot id="slot"></slot>
      <div id="fit" draggable on-track="_onDrag">
        <div id="top" hidden$="[[!resizeTop]]" on-track="_onResize"></div>
        <div id="right" hidden$="[[!resizeRight]]" on-track="_onResize"></div>
        <div id="bottom" hidden$="[[!resizeBottom]]" on-track="_onResize"></div>
        <div id="left" hidden$="[[!resizeLeft]]" on-track="_onResize"></div>
        <div id="topLeft" hidden$="[[!resizeTopLeft]]" on-track="_onResize"></div>
        <div id="topRight" hidden$="[[!resizeTopRight]]" on-track="_onResize"></div>
        <div id="bottomLeft" hidden$="[[!resizeBottomLeft]]" on-track="_onResize"></div>
        <div id="bottomRight" hidden$="[[!resizeBottomRight]]" on-track="_onResize"></div>
      </div>
    </div>
  </template>

  <script>
    /**
     * `drag-resize`
     * A touch friendly resizable container with resize events.
     *
     * @customElement
     * @polymer
     * @demo demo/index.html
     */
    class DragResize extends Polymer.GestureEventListeners(Polymer.Element) {
      static get is() { return 'drag-resize'; }
      static get properties() {
        return {
          /**
           * Which directions the container can be dragged.
           * Any combination of `up`, `down`, `left`, or `right`; or `none`.
           */
          drag: {
            type: String,
            value: 'up down left right',
            observer: '_dragChanged',
            reflectToAttribute: true
          },
          /**
           * Which edges allow resize.
           * Any combination of `top`, `bottom`, `left`, or `right`; or `none`.
           * A corner is enabled when both of its adjacent sides are enabled.
           */
          edges: {
            type: String,
            value: 'top bottom left right',
            observer: '_edgesChanged',
            reflectToAttribute: true
          },

          /**
           * True if draggable in at least one direction.
           */
          draggable: {
            type: Boolean,
            value: false,
            readOnly: true,
            reflectToAttribute: true
          },
          /**
           * True if resizable on at least one edge.
           */
          resizable: {
            type: Boolean,
            value: false,
            readOnly: true,
            reflectToAttribute: true
          },
        };
      }

      connectedCallback() {
        super.connectedCallback();
        this._observer = new Polymer.FlattenedNodesObserver(this.$.slot,
          info => {
            this.box = this.$.slot.assignedNodes({flatten:true})
              .filter(n => n.nodeType === Node.ELEMENT_NODE)[0];
          });
      }
      disconnectedCallback() {
        super.disconnectedCallback();
        this._observer.disconnect();
      }

      _edgesChanged(edges) {
        if (typeof edges != 'string') return;
        this.resizeTop = edges.includes('top');
        this.resizeBottom = edges.includes('bottom');
        this.resizeLeft = edges.includes('left');
        this.resizeRight = edges.includes('right');
        this.resizeTopLeft = this.resizeTop && this.resizeLeft;
        this.resizeTopRight = this.resizeTop && this.resizeRight;
        this.resizeBottomLeft = this.resizeBottom && this.resizeLeft;
        this.resizeBottomRight = this.resizeBottom && this.resizeRight;
        this._setProperty('resizable', this.resizeTop || this.resizeBottom
          || this.resizeLeft || this.resizeRight);
      }

      _dragChanged(drag) {
        if (typeof drag != 'string') return;
        this.dragUp = drag.includes('up');
        this.dragDown = drag.includes('down');
        this.dragLeft = drag.includes('left');
        this.dragRight = drag.includes('right');
        this._setProperty('draggable', this.dragUp || this.dragDown
          || this.dragLeft || this.dragRight);
      }

      _onResize(e, track) {
        e.stopPropagation();
        // Fix for half-pixel ddx/y when touching.
        const dx = Math.round(track.ddx || 0);
        const dy = Math.round(track.ddy || 0);

        // if (track.state == 'start') {
          // console.log('resizing', e.target.id, this.box);
        // }

        // Remember top-left point between runs.
        if (this.top === undefined) this.top = this.box.offsetTop || 0;
        if (this.left === undefined) this.left = this.box.offsetLeft || 0;

        // Values to change
        let top = this.top;
        let left = this.left;
        let height = this.box.offsetHeight;
        let width = this.box.offsetWidth;

        // If this line moved to the top, resizing fails.
        const translate = this._sidesToTranslate(this.box);

        if (e.target.id.includes('top')) {
          height += -dy;
          if (height < 0) height = 0;
          else if (translate.top) top += dy;
        } else if (e.target.id.includes('bottom')) {
          height += dy;
          if (height < 0) height = 0;
          else if (translate.bottom) top += -dy;
        }

        if (e.target.id.toLowerCase().includes('left')) {
          width += -dx;
          if (width < 0) width = 0;
          else if (translate.left) left += dx;
        } else if (e.target.id.toLowerCase().includes('right')) {
          width += dx;
          if (width < 0) width = 0;
          else if (translate.right) left += dx;
        }

        this.$.container.style.transform = `translate(${left}px, ${top}px)`;
        this.box.style.height = height + 'px';
        this.box.style.width = width + 'px';

        // if (track.state == 'end') {
        //   console.log(e.target.id, 'moved', track, {
        //     transform: this.box.offsetParent.style.transform,
        //     height: this.box.style.height,
        //     width: this.box.style.width,
        //   });
        // }

        this._fire('resize', track);
        this.top = top;
        this.left = left;
      }

      _onDrag(e, track) {
        if (!this.draggable) return;

        // Fix for half-pixel ddx/y when touching.
        // const dx = Math.round(track.ddx || 0);
        // const dy = Math.round(track.ddy || 0);
        const dx = track.dx || 0;
        const dy = track.dy || 0;

        // Remember top-left point between runs.
        if (this.top === undefined) this.top = this.box.offsetTop || 0;
        if (this.left === undefined) this.left = this.box.offsetLeft || 0;

        if (track.state == 'start') {
          // console.log('dragging...');
          this._dragStartTop = this.top;
          this._dragStartLeft = this.left;
        }



        // Values to change
        let top = this._dragStartTop;
        let left = this._dragStartLeft;

        if ((this.dragUp && dy <= 0) || this.dragDown && dy >= 0) {
          top += dy;
        }
        if ((this.dragLeft && dx <= 0) || this.dragRight && dx >= 0) {
          left += dx;
        }

        this.$.container.style.transform = `translate(${left}px, ${top}px)`;

        // console.log(top, left, dx, dy)
        this._fire('drag', track);
        this.top = top;
        this.left = left;
      }

      _sidesToTranslate(element) {
        let top = element.offsetParent.offsetTop;
        let left = element.offsetParent.offsetLeft;
        element.style.height = (element.offsetHeight + 2) + 'px';
        element.style.width = (element.offsetWidth + 2) + 'px';
        return {
          top: element.offsetParent.offsetTop == top,
          left: element.offsetParent.offsetLeft == left,
          bottom: element.offsetParent.offsetTop == top - 2,
          right: element.offsetParent.offsetLeft == left - 2,
        };
      }

      /** Copy the Polymer 1.x fire implementation. */
      _fire(name, data, options = {}) {
        options.detail = data;
        if (options.bubbles === undefined) options.bubbles = true;
        if (options.composed === undefined) options.composed = true;
        this.dispatchEvent(new CustomEvent(name, options));
      }

      /**
       * Triggered when the element is resized.
       * @event resize
       * @param {track} object The on-track event detail.
       */

      /**
       * Triggered when the element is dragged.
       * @event drag
       * @param {track} object The on-track event detail.
       */
    }

    window.customElements.define(DragResize.is, DragResize);
  </script>
</dom-module>
